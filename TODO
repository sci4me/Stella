Bugs:
 - It is possible to place items without having one "held"
   - Click an item in your inventory
   - Close the inventory
   - Place the item
   - Cry

Features:
 - Entities
   - Item Entities
   - Other Entities? (eventually, TM)
 - Main Menu
   - Ability to create new worlds, load saved worlds, edit settings, and quit
 - Save Games
   - This ties into chunk management pretty significantly
     - In a real-world scenario, whenever we want to _get_ a chunk
       We first need to check if that chunk already exists, possibly in a cache, or on disk
       If not, only then do we generate it.
     - Whenever we want to unload a chunk, say because the player walked away from it,
       we need to serialize it to disk somehow. Or possibly a chunk cache, before disk.
 - Audio
   - Obviously we'll probably want to implement the basics:
     - Ability to play music; streaming audio
     - Ability to play short sound effects
 - Particle Systems
 - Time Step Handling
   - Currently we aren't doing _anything_
     - We're just updating and rendering in a loop
   - We _at least_ want to do something like "semi-fixed timestep"
     - Not perfect...
     - The "best" option is to use interpolation for remaining
       time. But, this is a fair amount of overhead (on the programmer!)
       especially once we consider things like tiles that are doing their
       update logic, etc.
       I find it hard to believe that I'll actually do this.
 - Key/Mouse Event Dispatch / Handling
   - Instead of having to like, hackily debounce keys with a static bool...
 - Shift clicking in inventories!
 - Ability to select part of a stack vs only the entire thing
 - Click outside of ImGui window to close it? Maybe?
   - For in-game UIs? Or, some of them?
     - Inventory, Chest, Furnace, etc.?
   - Also, pressing E opens the inventory, shouldn't it close it too?

Code/Dev Features/Quality:
 - Consider removing GLEW
   - We could, relatively easily, handle any
     extension querying and function pointer
     lookup that we need, on a function-by-function
     basis.
 - Build GLEW and GLFW from source!
   - Difficult to do on Windows (maybe)
     - Not going to use VS!!!
       - So we'll just write our own
         build scripts...
 - In-Game Profiler
   - Instrumentation; use it
 - Make our own String type
 - Rename Tile to Tile_Entity
 - Internal
   - #define internal static
 - HOT CODE RELOAD!!!!!
   - Definitely non-trivial to implement!
     - We have a ton of state.. sorta.
   - Totally worth doing though!
     - Not hard conceptually: just use a dynamic
       library to hold the actual game code, and
       a "playform layer" (although in our case,
       it won't be a true _platform_ layer.. but..
       semantics.. n stuff..)
       And then just uh, have this platform layer (what
       gets build as the actual .exe) load and reload
       the dynamic library if it changes.
       Just have to be really careful/specific/controlled/whatever
       about memory; all allocation must happen from within
       the platform layer so that when the dynlib reloads, it can
       just keep using that same memory.
   - We may want to move the GLEW/GLFW stuff into platform layer?
     - Well, actually, we should probably just leave GLEW in the
       dynlib and just call glewInit every time...
     - As for GLFW, I think we'll just try leaving it in the dynlib
       and saving the ... window...
       - Or maybe we should just .. move it.. idk.
   - We will absolutely have to ensure that ALL memory allocation
     goes through our own API so that we can control _where_ the
     allocations happen. i.e. you can't allocate memory in the dynlib
     and expect it to survive reload! The call to malloc must occur
     within the persistent executable.
   - We also would like to make it possible to build either as an exe
     or as an exe and a dll/so, etc. depending on whether it's a dev
     or release build. This shouldn't be hard; maybe just a bit finicky.
 - Shader Abstraction
   - Bind/Unbind
   - Ability to handle uniforms
 - Framebuffer abstraction
   - "Just a wrapper" for OpenGL framebuffers
     - Ability to create and destroy them
     - Ability to bind and unbind them
     - Ability to configure what buffers/textures are attached to the FBO
       - i.e.  attach a texture to `GL_COLOR_ATTACHMENT0`
 - Logging !!!
   - Configurable (?)
   - Console Logging
   - File Logging
   - printf style API
 - Better Build System

Quality/Optimization:
 - Verify that we only have _one_ copy of GLEW being build
   into our executable! I _think_ this is the case.. but..
   - I'm really not sure if .. like..
     We're not explicitly linking GLEW into the static lib for
     imgui, so... presumably it assumes that it will be linked
     in at a later stage, as it is in our main build?
     - Is this how linking works though? Can you do this?
       - Build a static library that must be linked into something else,
         _alongside_ another static library
   - Also, tbh, I don't know ... if/how our imgui build is working;
     It's including <GLEW/*> rather than "glew/*" so, is it using
     headers _outside of /vendor? It would have to be???
 - Instead of using N textures for ores that are diminishing,
   just render them differently by using different UVs!
 - Tests
   - It's starting to get to the point where we have easily
     testable things that probably _should_ be tested.
 - Change from "init" and "free" to constructors and destructors
   - I didn't want to have to do it, but... fucking... C++ yo.
     - The problem with init and free is that you can't change
       the parameter types when you're overriding it in a
       child struct. So. F.
   - Not 100% convinced about this yet, so we'll push it off
     - But probably, we want to do this?... ..er.. yeah.
   - Okay yeah, update on this one: ctors/dtors are evil! Find a way
     to avoid them at all costs!
 - Organization
   - Probably only want one level of subdirectory in `src`
   - Namespaces! structs! etc.
   - Could probably apply this to the TODO file itself tbh lol
   - OMG WE REALLY NEED TO DO THIS!!!
     - At the time of writing this text:
       - 26 files!!!
       - 3196 lines!!! 
     - Dependencies between files is getting more annoying.....
       - Better organization should help
         - If not, resort to hpps
 - Maybe use references more? And const references? er....
   - Definitely need to do some research/learning, etc. to know for sure...
     - But maybe.. maybe it's a good idea in some/many places. Dunno.    
 - Combine `batch` and `chunk` shaders?
   - Maybe not; I'm not sure if this is a good idea or not
     - Maybe it will be in the short term but we'll have to change it later on anyway?
     - Maybe we can just use a single shader and just pass it the data it needs to handle the cases instead of using multiple shaders?
       - Definitely not once we start doing less-than-trivial things
         - Lighting
         - OpenGL in ImGui
   - So, yeah uhm, maybe don't combine them? I don't even know.
   - Although... if I eventually want the ability to tint chunk tiles anyway,
     then the shaders become equivalent, so, yes.